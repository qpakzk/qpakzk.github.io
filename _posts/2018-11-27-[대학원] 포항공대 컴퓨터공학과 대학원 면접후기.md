---
layout: post
title: "[대학원] 포항공대 컴퓨터공학과 대학원 면접후기"
description: ""
tags: [대학원]
redirect_from:
  - /2018/11/27/
---

# [대학원] 포항공대 컴퓨터공학과 대학원 면접후기

2018년 11월 2일에 실시한 2019년도 포항공과대학교 대학원 입시 일반전형 2차 컴퓨터공학과 면접에 응시하였다.

## 서류 전형 합격

2018년 10월 30일 오후 2시에 서류 전형 합격자 발표가 났고 잠시 후에 메일로 자세한 공지가 왔다. 10월 31일 오후 6시까지 면접 참석 여부에 대한 답신을 보내야 했다.

## 면접장 입실

2018년 11월 2일 포스텍 2공학관 1층 102호 대기실에 오후 12시 30분까지 입실했다. 대기실에는 20명 정도 되는 면접자들이 면접에 참석하였다. 면접자들은 모두 양복 차림이었다.

대기실에 입실하면 원서 접수 시 작성했던 서류와 성적표 등의 출력물을 배부받게 된다. 면접방에 들어갈 때마다 면접관 교수님들께 보여드려야 한다. 원서 출력물 이외에 과일 한 컵, 샌드위치, 생수, 주스 등도 받았다.

스마트폰과 태블릿 PC는 제출해야 하고 노트북은 제출하지는 않지만 사용해서는 안된다. 대기실에 입실한 순간부터 전자기기를 사용할 수 없다. 대기 시간 동안 태블릿 PC로 하나라도 더 준비하려고 했는데 낭패를 봤다. 대기 시간에 면접을 계속 준비하고자 한다면 반드시 하드카피로 들고 가야 한다.

오후 1시부터 면접이 시작되었다. 대기실에서 기다리면서 면접자들이 호명받는 순서대로 면접을 보게 된다. 그래서 대기 시간이 긴 면접자도 있는 반면, 면접이 금방 끝나는 면접자도 있다. 면접 순서의 기준은 무엇인지 잘 모르겠다. 이름순은 아니었다.

## 면접

면접 내용은 시간이 좀 지난 뒤에 기억에 의존하여 작성하였기 때문에 내용이 누락되거나 순서가 뒤죽박죽일 수도 있다. 그리고 면접에서 내가 한 답변이 틀린 내용일 수도 있다.

### Area 1 : 알고리즘 & 오토마타

입실 전에 시험지가 주어졌다. 10분 동안 문제를 풀고 들어갔다. 면접관은 한욱신 교수님(교1)과 유환조 교수님(교2)이었다.

시험지의 질문은 다음과 같았다. 질문은 영어로 써져 있었다.

1. 자신이 가장 좋아하는 알고리즘(알고리즘이었는지 정렬 알고리즘이었는지 기억이 잘 안남)을 설명하고 좋아하는 이유도 설명
2. 그리디 알고리즘이 무엇인가
3. 허프만 인코딩이 무엇이고 왜 그리디 알고리즘으로 구현하는가
4. 허프만 인코딩의 pseudocode가 주어졌고 pseudocode를 설명하고 주어진 예제의 실행 결과가 무엇인가

나 : 안녕하세요.

교2 : 원서 어디있어요?

나 : 앗!! 맞다!! (원서 출력물을 대기실 책상에 놓고 면접방에 들어가고 말았다. ㅠㅠ 후다닥 대기실에 뛰어갔다 왔다.)

교1 : 문제 푼거 설명하세요.

나 : 저는 quicksort에 대해 설명하도록 하겠습니다. quicksort는 피벗을 기준으로 피벗 왼쪽에는 피벗보다 작은 값, 오른쪽에는 피벗보다 큰 값이 오도록 합니다. 그리고 피벗으로 나눠진 두 구간에서 이 과정을 반복하여 정렬에 도달하도록 하는 알고리즘입니다.

교1 : 다른 정렬 알고리즘도 있는데 quicksort를 왜 quicksort를 선정하였나요?

나 : quicksort가 빠르게 정렬해주는 알고리즘이기 때문입니다.

교1 : time complexity가 얼마나 되나요?

나 : 평균 time complexity는 O(nlogn)이지만 최악의 경우 O(n^2)입니다.

교1 : time complexity가 O(nlogn)인 다른 정렬 알고리즘은 없나요?

나 : mergesort와 heapsort가 있습니다.

교1 : time complexity가 동일한데 왜 quicksort를 더 좋아하죠?

나 : ... mergesort는 space complexity가 quicksort보다 높아서 정렬할 때 quicksort보다 더 많은 메모리를 차지하기 때문에 mergesort보다 quicksort를 더 선호합니다. 그리고 heapsort는 ... (기억이 안남 ㅠ) quicksort가 최악의 경우만 아니라면 같은 O(nlogn)이지만 quicksort가 heapsort보다 성능이 더 좋다고 ... 왜 그런지 Stack Overflow에서 읽었었는데 기억이 잘 안납니다.

교1 : ㅋㅋㅋ 다음 문제 풀어봐요.

나 : 그리디 알고리즘은 local optimum을 찾는 알고리즘입니다.

교1 : 그게 끝?

나 : local optimum을 찾아가면서 궁극적으로는 global optimum에 도달하는 알고리즘입니다.

교1 : 다음 문제 풀어보세요.

나 : 허프만 인코딩은 빈도가 높은 값에 대해서는 짧은 코드로 인코딩하고 빈도가 낮은 값에 대해서는 긴 코드로 인코딩합니다.

교1 : 다음

나 : ... 제가 pseudocode를 제대로 이해를 못했습니다. (허프만 인코딩이 뭔지 기억이 안나다가 면접실 들어가기 직전에 떠올라서 코드를 제대로 이해하지 못한채 들어갔다. ㅠ)

교1 : 문제 10분 정도 볼 수 있는 시간 주지 않나요?

나 : 네 맞습니다. ㅠㅠ

교1 : 앞 질문 제대로 대답한거 보면 허프만 인코딩이 뭔지 알고 있는데?

나 : 기억이 안나다가 면접실 들어오기 직전에 떠올랐습니다. ㅠㅠ. 일단 실행 결과는 블라블라입니다. (예제에서 인코딩이 짧은 순서대로 답을 하는 것이었다.)

교1 : 동작과정 설명해보세요.

나 : ... (생각중)

교2 : 일단 시간이 없으니까 다음 질문을 할게요.

나 : 네 ㅠㅠ

교2 : 그리디 알고리즘은 문제가 무엇인가요?

나 : 그리디 알고리즘은 local optimum을 찾으면서 global optimum에 도달하는 방식이기 때문에 global optimum에 도달하지 못하고 local optimum에 빠져 버릴 수가 있습니다.

교2 : DP는 무엇인가요?

나 : DP는 전체 문제를 부분 문제로 잘게 쪼개서 최적해를 구한 뒤 이를 저장하고 그 최적해들을 통해 전체 문제의 최적해를 구하는 방식입니다.

교2 : DP가 갖는 특징이 무엇인가요?

나 : DP의 특성으로 optimal substructure와 overlapping subproblem이 있습니다. optimal substructure는 부분 문제들의 최적해들을 전체 문제의 최적해가 포함하고 있는 것을 말합니다. overlapping subproblem은 divide-and-conquer와 차이나는 부분으로 ...

교1 : ㅋㅋㅋㅋㅋㅋㅋㅋ 인터넷에서 족보 구해서 달달 외워왔네 ㅋㅋ

나 : ㅋㅋㅋ ... (머쓱)

교1 : 아니, 잘했다는 의미예요. ㅋㅋㅋ

나 : overlapping subproblem은 부분 문제들 간에 상관 관계가 있는 경우를 말합니다. divide-and-conquer는 부분 문제들 간에 상관 관계가 없는 경우에 활용해야 하는 반면 DP는 부분 문제들의 결과를 저장해놨다가 재사용하기 때문에 overlapping subproblem을 해결할 때 장점을 갖게 됩니다.

교2 : DP로 해결하는 문제 중에 time complexity가 exponential한 경우가 있나요?

나 : ... 예시 문제가 기억이 안나는데 그러한 경우가 있었습니다. brute-force로 하면 최악의 경우에는 n!이 나와서 차라리 DP로 풀면 2^n 시간 안에 해결할 수 있기 때문에 사용합니다.

교2 : 차라리?

나 : 네?

교2 : 차라리가 아니라 DP 말고는 해결할 수 없지 않나요?

나 : 아... 네... 제가 차라리라고 한 이유는 DP를 쓸 때 점화식을 도출하는게 어려워서 그렇게 표현했습니다.

교2 : DP처럼 최적화 잘되는 것도 없는데... 싫어하면 안되는데 ㅋㅋㅋ. 그럼 오토마타 질문해볼게요.

나 : 네!

교2 : 어떤 연산자가 어떤 language에 closed되었다는게 무슨 의미죠?

나 : ?!?!?!?!?!?!?!?!?! 음... regular language는 finite automata로 인식할 수 있습니다. (질문의 의도를 전혀 파악하지 못했다.)

교2 : 자세히 설명해봐요.

나 : 아... regular language로 예를 들면 어떤 string을 regular expression으로 표현할 수 있으면 그 string은 regular language에 속하게 됩니다. regular expression의 연산자로는 union, star, concatenation이 있습니다.

교2 : 질문이 어떤 연산자가 어떤 language에 'closed'되었다는 게 무슨 뜻이냐는 거예요.

나 : (혼잣말로) 아... 닫혀있다... 어떤 string들이 어떤 language에 속한다고 가정했을 때 그 string들을 이용하여 연산자로 연산하여 그 결과 string도 language에 속하게 된다면 해당 연산자는 language에 대해 closed되었다고 말합니다.

교2 : 시간이 끝났네요.

교1 : 공부 열심히는 한거 같은데....

나 : 감사합니다.

교2 : (나갈 때) 혹시 숭실대에서 오토마타 배우나요?

나 : 네 3학년 2학기에 배웁니다. 안녕히 계세요.

### Area 3: 프로그래밍언어 & 운영체제

시험지가 주어지지 않았고 Area 1이 끝나자마자 곧바로 들어갔다. 면접관은 홍원기 교수님(교1)과 곽수하 교수님(교2)이었다.

나 : 안녕하세요.

교1 : 자기소개를 하세요.

나 : 저는 숭실대학교 컴퓨터학부 4학년에 재학 중인 XXX 입니다. 포항공대에 진학하여 훌륭한 연구자로 성장하고 싶습니다. 감사합니다.

교1 : 대학원에 진학하여 연구하고 싶은 분야는 무엇인가요?

나 : 블록체인을 연구하고 싶습니다.

교1 : 그 이유가 무엇인가요?

나 : 블록체인이 문제가 많고 아직 제대로 활용되고 있지 않습니다. 그러나 블록체인이 꼭 필요한 분야가 분명이 존재할 것이라고 확신하고 연구를 통해 그 분야에 꼭 쓰일 수 있도록 블록체인 발전에 이바지하고 싶습니다.

교1 : 여태까지 구현해본 프로그램들 중에 제일 크고 자랑할만한 프로젝트를 말해보세요.

나 : 저는 스마트컨트랙트를 이용하여 계약을 관리해주는 DAPP을 개발하였습니다. 계약이라고 표현은 했지만 실제로는 어떤 파일이든 제가 개발한 시스템에 입력하면 해당 파일을 sha256을 통해 해시를 추출하고 시스템에 저장하여 위변조 여부를 체크합니다.

교1 : 스마트컨트랙트는 솔리디티로 짰나요?

나 : 네!

교1 : 그럼 여태껏 자주 썼던 프로그래밍언어는 무엇인가요?

나 : C, C++, 자바스크립트 정도입니다.

교1 : Go는 안써봤나요? 블록체인에 많이 쓰이는데...

나 : 자세히는 모릅니다. 블록체인에서 많이 쓰여서 Go나 Rust 등을 공부할 계획입니다.

교1 :프로그래밍언어 수업 시간에 배웠던 것들을 설명해보세요.

나 : ... lexical Analysis, Semantic Analysis 등을 배웠고 이때 Yacc, Lex 툴들을 사용해 봤습니다. 그리고 ... 프로그래밍 언어의 특성에 대해서 배웠습니다. 예를 들면 변수가 뭔지, 타입이 뭔지 등에 대해 배웠습니다. ... 그리고 static typing, dynamic typing을 배웠고 subprogram 등에 대해서도 배웠습니다. (그냥 기억나는거를 최대한 말했다.)

교1 : 프로그래밍언어의 종류에 대해서는 무엇을 배웠나요?

나 : 제가 수강한 수업의 교수님께서는 C 중심으로 강의하셨습니다.

교1 : 프로그래밍언어란 무엇인가요?

나 : ... 인간이 컴퓨터와 의사소통하기 위해 프로그램을 짜는데 프로그램을 작성할 때 쓰이는 것이 프로그래밍언어라고 합니다.

교1 : 프로그램을 짠다음 실행시킬 때까지의 과정을 설명해보세요.

나 : 소스코드를 짠다음 컴파일러로 컴파일을 하면 어셈블리 코드가 생성됩니다. 그리고 어셈블러로 어셈블하면 목적 코드가 생성됩니다. 링커를 이용하여 목적 코드와 라이브러리를 연결하면 실행파일이 생성됩니다.

교2 : 이제 운영체제에 대해 질문하도록 하겠습니다. 질문할 내용이 많으니 빠르게 진행하겠습니다. 잘 모르겠으면 일단 넘어가도록 하겠습니다.

나 : 네!

교2 : CPU 스케줄링을 왜 하나요?

나 : 다중 프로그래밍을 하려면 여러 프로세스 또는 쓰레드가 동시에 실행되어야 하는데 이때 프로세스나 쓰레드의 실행 순서를 결정해주기 위해 사용합니다.

교2 : 또 다른 이유는 없나요?

나 : 네? ... (모름ㅠ)

교2 : 동기화가 뭔가요?

나 : 여러 프로세스나 쓰레드가 공유 자원을 동시에 접근하려고 할 때 이를 제어하는 것을 말합니다.

교2 : 공유 자원의 동시 접근을 왜 제어해야 하나요?

나 : data consistency를 유지해야 하기 때문입니다.

교2 : 왜 data consistency를 유지해야 하나요?

나 : ... 공유 자원에 0라는 값이 있을 때 프로세스 A가 공유 자원에 접근하여 0을 1로 수정하고 있는데 프로세스 B가 0을 의도하고 공유 자원에 접근하여 1을 읽어가면 데이터의 일관성이 깨지기 때문에 문제가 발생합니다.

교2 : 동기화 기법 중에 세마포어와 뮤택스가 있잖아요? 이 두가지의 차이가 무엇인가요?

나 : 뮤택스는 바이너리 세마포어입니다. 세마포어는 공용 변수로 wait을 통해 변수의 값을 감소시키고 signal을 통해 변수의 값을 증가시킵니다. 뮤택스는 0과 1을 통해서만 상태를 표현합니다.

교2 : 그럼 뮤택스만 써도 되는데 굳이 세마포어는 왜 쓰는 것인가요?

나 : 세마포어 변수값이 양수이면 현재 남아 있는 공유 자원의 개수를 알 수 있고 0이면 모든 공유자원이 프로세스에 의해 점유된 상태임을 알 수 있으며, 음수이면 그 절대값이 블록 상태의 프로세스 개수임을 알 수 있습니다.

교2 : mutual exclusion으로 발생할 수 있는 문제가 무엇이 있을까요?

나 : 데드락이 발생할 수 있습니다.

교2 : 데드락이 무엇인가요?

나 : 프로세스들이 실행하지 않고 대기 상태에 있는 현상을 말합니다.

교2 : 왜 그러한 상태가 되는 것인가요?

나 : 프로세스들이 서로 자원을 점유한 채 서로의 자원을 요청하기 때문입니다. 대표적으로 환형 대기가 있습니다. 프로세스 A가 어떤 자원을 점유한 채 다른 자원을 요청하고 있습니다. 근데 프로세스 B가 그 자원을 점유하고 있고 프로세스 B도 프로세스 A가 점유하고 있는 프로세스를 요청하여 대기 상태에 빠지게 됩니다.

교2 : 프로세스에서 선점, 비선점이 무엇인가요?

나 : 선점은 프로세스가 CPU를 점유하고 있을 때 다른 프로세스에게 점유권을 빼앗길 수 있는 것을 말하고 비선점은 그 반대입니다.

교2 : XXX 학생이 쓰고 있는 PC에 윈도우가 설치되어 있다고 합시다. 윈도우는 선점 방식인가요? 비선점 방식인가요?

나 : 선점 방식입니다.

교2 : 그럼 자동차에 OS가 설치되어 있다면 그 OS는 선점 방식인가요? 비선점 방식인가요?

나 : 비선점적인 요소가 필요하다고 생각합니다.

교2 : 왜 그렇게 생각하나요?

나 : 자동차의 경우 반드시 일정 시간 안에 반드시 계산하여 결과를 도출해야 하는 상황이 발생할 수 있습니다. 즉 Real-Time OS를 사용해햐 합니다. Real-Time OS는 데드라인까지 반드시 결과를 내야하는 OS를 말합니다. Real-Time OS를 사용하지 않으면 인명 피해와 같은 치명적인 상황이 발생할 수 있습니다.

교2 : 시간이 끝났습니다.

나 : 감사합니다.

### Area 2 : 논리회로 & 컴퓨터구조

시험지가 주어졌고 10분 동안 풀고 들어갔다. 면접관은 김대진 교수님(교1)과 김종 교수님(교2)이었다.

시험지 내용은 다음과 같았다. 질문은 전공 용어를 제외하고 한글로 써져 있었다.

1. Boolean Algebra
    1. Boolean Algebra란 무엇인가?
    2. functionally complete set of operations란 무엇인가?
    3. functionally complete한 최소 원소 집합은?
    4. NAND 게이트로 OR, NOT, AND 게이트 표현하기
2. Overflow 문제
    1. C = A + B와 C = A - B일 때 오버플로우가 되는 경우 따져보기
    2. 오버플로우가 되는 조건을 두 가지로 표현해보기
3. 세차장 문제 (과거 기출과 동일). 4단계로 진행, 각 단계는 15분, 400대 차량. (기출 문제와 동일)
    1. 단일 세차장 일 때 걸리는 시간
    2. 4개 세차장 일 때 걸리는 시간
    3. 하나의 파이프라인닝 적용할 때 걸리는 시간
    4. 4개의 파이프라이닝 가진 슈퍼스칼라일 때 걸리는 시간

나 : 안녕하세요.

교1 : 자기소개해보세요.

나 : 저는 숭실대학교 컴퓨터학부 4학년에 재학 중인 XXX입니다. 포항공대에 진학하여 훌륭한 연구자로 성장하고 싶습니다. 감사합니다.

교1 : 문제를 칠판을 이용해서 처음부터 풀어보세요.

나 : 1-1에서 Boolean Algebra는 기본 연산자 AND, OR, NOT을 이용해서 1 또는 0으로만 Boolean expression을 나타내는 대수를 말합니다. 그리고 1-2에서 어떤 연산자 집합이 functionally complete하다는 것은 그 연산자 집합으로 다른 모든 boolean 연산자를 표현할 수 있는 것을 말합니다. 1-3은 {NAND}와 {NOR}가 있습니다. 1-4는 (칠판을 통해 회로를 그림)

교1 : OR에 NAND가 왜 하나 더 있죠?

나 : NAND로 OR를 표현할 때 ((A + B)')' = (A'B')' 표현하면...  (잘못 그렸다.) 아 죄송합니다. 게이트 하나를 더 그렸습니다.

교1 : 다음 문제를 풀어보세요.

나 : (2번에서 엄청 헤맸다. 2-2는 무엇을 나타내라는 것인지 잘 몰랐다.) 2's complement를 가정하고 풀어보겠습니다. (칠판에 써가면서 설명했다.) C = A + B에서 A, B의 최상위 비트가 각각 0, 0이고 C의 최상위 비트가 1이 되면 오버플로우입니다.  A, B의 최상위 비트가 각각 1, 1이고 C의 최상위 비트가 0이 되면 오버플로우입니다.

교1 : C = A - B일 때도 풀어보세요.

나 : 흠.... (칠판에 끄적이면서) 그냥 뺄셈도 결국 A + (-B)이므로 덧셈과 같습니다.

교1 : 근데 왜 A가 1이고 B가 1인데 C가 0이 되나?

나 : 네????? 아.. 잘못 썼습니다. (당황해서 한동안 뇌가 멈춤) A가 0이고 B가 1일 때 C가 1이면 오버플로우, A가 1이고 B가 0일 때 C가 0이면 오버플로우입니다.

교1 : 그럼 지금 4가지 결과를 이용해서 오버플로우가 발생하는 조건을 boolean expression으로 표현해보세요.

나 : ?!?!?!?!?!?!?!?!?!?!?!?!?!

교1 : 그 Minterm으로 표현하는거 있잖아요?

나 : 아... (A = B + C일 때 하나만 표현했는데 complement를 반대로 표기함)

교1 : 반대 아닌가?

나 : 아... 잘못 썼습니다.

교1 : 그래요. 그런 식으로 나머지 세 개도 표현해서 합으로 표현하면 오버플로우가 되는 첫 번째 조건입니다. 다른 조건은 무엇이 있나요?

나 : Maxterm 말씀하시는건가요?

교1 : 아니... 시간이 부족하니까 답을 말해주자면 Carry-In과 Carry-Out으로 표현하는 방법이 있어요. 그냥 truth table 그려보면서 따져보면 쉽게 나와요.

나 : 네...

교1 : 마지막 문제는 시간이 없으니까 빨리 답이랑 그 이유를 설명해보세요.

나 : (생략)

교2 : 이제 자리에 앉아요. Instruction Set Architecture가 무엇인가?

나 : ... 하드웨어와 로우 레벨 소프트웨어의 인터페이스를 말합니다.

교2 : 그럼 Instruction Set Architecture을 구성하는게 무엇이 있나요?

나 : ... opcode, operand가 있습니다.

교2 : Instruction이 있으니까 당연한 얘기고, 그리고?

나 : (몰라서 아무말 대잔치) CPU, Control Unit 등이 있습니다.

교2 : ????

나 : (몰라서 질문 외적인 답을 ...) ISA를 CPU 설계 방식으로 이해해서 같은 ISA를 지닌 다른 구현 방식의 CPU가 있으면 같은 어셈블리 코드를 사용할 수 있습니다.

교2 : ???? 마이크로 아키텍처가 뭔가요?

나 : 아키텍처를 작게 구성한 것입니다.

교2 : 그건 그냥 번역한거고 ㅋㅋ

나 : ...

교2 : 그럼 블라블라 prediction 알아요?

나 : 네? 아뇨... (뭐라고 하셨는지 제대로 못알아 들음)

교2 : branch prediction은?

나 : 아... 그건 pipelining 시 control hazard가 발생할 수 있는데 그때의 해결책으로 branch prediction을 사용합니다. (더 설명했어야 했는데...)

교2 : TLB와 캐시의 차이가 뭐예요?

나 : (TLB 수박 겉핡기 식으로 보고 왔는데 ...) TLB는 메인 메모리에 있는 페이지 테이블을 캐시에 매핑시킨 것입니다. 그리고 ... 비교 대상이 뭐였죠?

교2 : 캐시

나 : TLB가 캐시 안에 있다고 알고 있습니다.

교2 : ?? 확실한가요?

나 : 네!

교2 : 잘못 알고 있는데 ...? L1, L2 캐시 알아요?

나 : (이름만) 네!

교2 : 그럼 TLB는 L1, L2 캐시에 어디에 있는거예요? (내가 TLB가 캐시에 있다고 주장하니까 교수님께서 이런 질문을 던지신거 같다.)

나 : 그렇게 자세히는 ... 모... 모릅니다...

교2 : 시간 되었네요.

나 : 감사합니다.

마지막방을 말아먹고 나왔다. ㅠㅠ

## 면접 직후

면접이 끝나고 대기실로 돌아와 원서 출력물을 다시 제출하고 태블릿 PC, 스마트폰을 되돌려 받고 면접장에서 나왔다.

## 최종 결과

최종 합격하였다.

![]({{ site.baseurl }}/assets/images/grad/grad-accept.png)
